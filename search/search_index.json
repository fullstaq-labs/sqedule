{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Sqedule docs Github Read User Guide Read Server Guide What is Sqedule? Sqedule is an application release auditing & approval platform. Auditing : Sqedule allows teams to have a central audit log of all released applications and their versions. This provides valuable information when troubleshooting complex application architectures that may involve many microservices or components. Approval : Sqedule helps organizations that traditionally used formal (ITSM-based) change & release management processes, and are transitioning to adopt more DevOps-style continuous release processes. Sqedule helps such organizations implement a more restrictive CI/CD. Sqedule allows change & release managers to define release approval rules. Some of these rules are fully automated (for example: \"only allow releasing in this time window\"), others involve manual approvals from specific people or teams. Sqedule works by integrating with CI/CD pipelines, so that all releases are logged into Sqedule. If rules are defined, then the CD pipeline only proceeds with releasing when all rules allow so. Sqedule consists of: An HTTP server with a JSON API. A web interface (part of the HTTP server). A CLI for interacting with the HTTP server. Why Sqedule as an approval platform The transition of a formal (ITSM based) change & release management process towards a DevOps-style software delivery is very challenging for some organizations. We go from a carefully planned deployment every couple of weeks, to an automated process that deploys updated software multiple times per day without human intervention. Change and release managers tend to feel powerless and out-of-control during these transitions. With Sqedule we are trying to bridge the gap between ITIL-style change/release management and CI/CD/DevOps processes, by automating the change approval processes centrally and allowing change & release managers to collaborate smoothly. Made with \u2764\ufe0f by Fullstaq Sqedule is made by Fullstaq. Learn more . Next up Read the User Guide to learn how to use Sqedule. Read the Server Guide to learn how to setup and administer a Sqedule server.","title":"Home"},{"location":"#welcome-to-the-sqedule-docs","text":"Github Read User Guide Read Server Guide","title":"Welcome to the Sqedule docs"},{"location":"#what-is-sqedule","text":"Sqedule is an application release auditing & approval platform. Auditing : Sqedule allows teams to have a central audit log of all released applications and their versions. This provides valuable information when troubleshooting complex application architectures that may involve many microservices or components. Approval : Sqedule helps organizations that traditionally used formal (ITSM-based) change & release management processes, and are transitioning to adopt more DevOps-style continuous release processes. Sqedule helps such organizations implement a more restrictive CI/CD. Sqedule allows change & release managers to define release approval rules. Some of these rules are fully automated (for example: \"only allow releasing in this time window\"), others involve manual approvals from specific people or teams. Sqedule works by integrating with CI/CD pipelines, so that all releases are logged into Sqedule. If rules are defined, then the CD pipeline only proceeds with releasing when all rules allow so. Sqedule consists of: An HTTP server with a JSON API. A web interface (part of the HTTP server). A CLI for interacting with the HTTP server.","title":"What is Sqedule?"},{"location":"#why-sqedule-as-an-approval-platform","text":"The transition of a formal (ITSM based) change & release management process towards a DevOps-style software delivery is very challenging for some organizations. We go from a carefully planned deployment every couple of weeks, to an automated process that deploys updated software multiple times per day without human intervention. Change and release managers tend to feel powerless and out-of-control during these transitions. With Sqedule we are trying to bridge the gap between ITIL-style change/release management and CI/CD/DevOps processes, by automating the change approval processes centrally and allowing change & release managers to collaborate smoothly.","title":"Why Sqedule as an approval platform"},{"location":"#made-with-by-fullstaq","text":"Sqedule is made by Fullstaq. Learn more .","title":"Made with \u2764\ufe0f by Fullstaq"},{"location":"#next-up","text":"Read the User Guide to learn how to use Sqedule. Read the Server Guide to learn how to setup and administer a Sqedule server.","title":"Next up"},{"location":"fullstaq/","text":"About Fullstaq Sqedule is made with by Fullstaq . Based in the Netherlands, Fullstaq helps organizations with complex IT environments to solve complex problems and to succeed in cloud native. Fullstaq helps by providing consultancy, training, managed services and project development services in the area of cloud native technologies, Kubernetes, containerization and DevOps. We differentiate ourselves with quality and passion . We've already helped clients such as ASML, Achmea, NS (Dutch Railways), Albert Heijn and Topgeschenken. What can we do for you? Come and say hi","title":"About Fullstaq"},{"location":"fullstaq/#about-fullstaq","text":"Sqedule is made with by Fullstaq . Based in the Netherlands, Fullstaq helps organizations with complex IT environments to solve complex problems and to succeed in cloud native. Fullstaq helps by providing consultancy, training, managed services and project development services in the area of cloud native technologies, Kubernetes, containerization and DevOps. We differentiate ourselves with quality and passion . We've already helped clients such as ASML, Achmea, NS (Dutch Railways), Albert Heijn and Topgeschenken. What can we do for you? Come and say hi","title":"About Fullstaq"},{"location":"server_guide/","text":"Introduction To use Sqedule , one must run a Sqedule server. This guide covers server installation and administration. The server is an HTTP server and requires a database . We do not provide a hosted version, so you must run it yourself on your own infrastructure. Luckily, this is easy: we provide pre-compiled binaries and containers . Even running on Kubernetes is a breeze. Please review the navigation menu and select your favorite installation method. Made with \u2764\ufe0f by Fullstaq Sqedule is made by Fullstaq. Learn more .","title":"Introduction"},{"location":"server_guide/#introduction","text":"To use Sqedule , one must run a Sqedule server. This guide covers server installation and administration. The server is an HTTP server and requires a database . We do not provide a hosted version, so you must run it yourself on your own infrastructure. Luckily, this is easy: we provide pre-compiled binaries and containers . Even running on Kubernetes is a breeze. Please review the navigation menu and select your favorite installation method.","title":"Introduction"},{"location":"server_guide/#made-with-by-fullstaq","text":"Sqedule is made by Fullstaq. Learn more .","title":"Made with \u2764\ufe0f&nbsp; by Fullstaq"},{"location":"server_guide/help_support/","text":"Help & support To report bugs or request features, please visit the issue tracker . To ask questions or to discuss things, please visit the discussion forum .","title":"Help & support"},{"location":"server_guide/help_support/#help-support","text":"To report bugs or request features, please visit the issue tracker . To ask questions or to discuss things, please visit the discussion forum .","title":"Help &amp; support"},{"location":"server_guide/concepts/database-schema-migration/","text":"Database schema migration During startup, the Sqedule server checks whether the database schema is up-to-date. If not then it will automatically migrate the database schema to the latest version. Note that schema migration may require sufficient permissions . Schema database migration is not concurrency-safe. This is the main reason why the Sqedule server currently does not support running multiple concurrent instances in its default configuration. You can disable automatic database schema migration . If you do this, then it is safe to run multiple concurrent Sqedule server instances, but you become responsible for running database schema migrations manually every time you upgrade the Sqedule server.","title":"Database schema migration"},{"location":"server_guide/concepts/database-schema-migration/#database-schema-migration","text":"During startup, the Sqedule server checks whether the database schema is up-to-date. If not then it will automatically migrate the database schema to the latest version. Note that schema migration may require sufficient permissions . Schema database migration is not concurrency-safe. This is the main reason why the Sqedule server currently does not support running multiple concurrent instances in its default configuration. You can disable automatic database schema migration . If you do this, then it is safe to run multiple concurrent Sqedule server instances, but you become responsible for running database schema migrations manually every time you upgrade the Sqedule server.","title":"Database schema migration"},{"location":"server_guide/concepts/multi-instance-safety/","text":"Multi-instance safety In its default configuration, the Sqedule server does not support running multiple concurrent instances. The main reason for this is because it automatically migrates the database schema during startup , which is not concurrency-safe. To make it safe to run multiple concurrent instances of the Sqedule server, disable automatic database schema migration .","title":"Multi-instance safety"},{"location":"server_guide/concepts/multi-instance-safety/#multi-instance-safety","text":"In its default configuration, the Sqedule server does not support running multiple concurrent instances. The main reason for this is because it automatically migrates the database schema during startup , which is not concurrency-safe. To make it safe to run multiple concurrent instances of the Sqedule server, disable automatic database schema migration .","title":"Multi-instance safety"},{"location":"server_guide/concepts/security/","text":"Security The Sqedule HTTP server is unprotected . There is currently no built-in support for authentication. Therefore you should not expose it to the Internet directly. Instead, you should put it behind an HTTP reverse proxy that supports authentication, for example Nginx with HTTP basic authentication enabled. Support for user accounts, and thus authentication, is planned for a future release.","title":"Security"},{"location":"server_guide/concepts/security/#security","text":"The Sqedule HTTP server is unprotected . There is currently no built-in support for authentication. Therefore you should not expose it to the Internet directly. Instead, you should put it behind an HTTP reverse proxy that supports authentication, for example Nginx with HTTP basic authentication enabled. Support for user accounts, and thus authentication, is planned for a future release.","title":"Security"},{"location":"server_guide/concepts/server-exe/","text":"The Sqedule server executable The Sqedule server comes with an executable named sqedule-server . This executable supports multiple subcommands, similar to how Git works. The most often used subcommand is run , which runs the HTTP server. You normally don't need to interact with this executable directly, because you're either using this executable through the SystemD service file, or through a container. But sometimes, such as when manually migrating the database schema , you do need to interact with it. Invoking the Sqedule server executable The way to invoke the Sqedule server executable depends on the installation method. When installed directly as a binary (without containerization) , invoke sqedule-server directly from your shell. Example: sqedule-server --help If sqedule-server is not in PATH, then invoke its full path: /path-to/sqedule-server When using containerization , invoke it through a container. The image's entrypoint is the Sqedule server executable. Example: docker run -ti --rm ghcr.io/fullstaq-labs/sqedule-server --help When using Kubernetes , obtain a shell in a Sqedule pod: kubectl exec -ti deploy/sqedule -- sh The sqedule-server executable is in PATH so you can invoke from this shell: sqedule-server --help !!! note The container environment is Alpine. Subcommands To see what subcommands sqedule-server supports, run it with --help . You should see something like this: $ sqedule-server --help Sqedule server Usage: sqedule-server [command] Available Commands: db Manage the database help Help about any command run Run the Sqedule API server version Show server version Flags: --config string config file (default $HOME/.sqedule-server.yaml) -h, --help help for sqedule-server --log-level string log level, one of: error,warn,info,silent (default \"info\") Use \"sqedule-server [command] --help\" for more information about a command.","title":"The Sqedule server executable"},{"location":"server_guide/concepts/server-exe/#the-sqedule-server-executable","text":"The Sqedule server comes with an executable named sqedule-server . This executable supports multiple subcommands, similar to how Git works. The most often used subcommand is run , which runs the HTTP server. You normally don't need to interact with this executable directly, because you're either using this executable through the SystemD service file, or through a container. But sometimes, such as when manually migrating the database schema , you do need to interact with it.","title":"The Sqedule server executable"},{"location":"server_guide/concepts/server-exe/#invoking-the-sqedule-server-executable","text":"The way to invoke the Sqedule server executable depends on the installation method. When installed directly as a binary (without containerization) , invoke sqedule-server directly from your shell. Example: sqedule-server --help If sqedule-server is not in PATH, then invoke its full path: /path-to/sqedule-server When using containerization , invoke it through a container. The image's entrypoint is the Sqedule server executable. Example: docker run -ti --rm ghcr.io/fullstaq-labs/sqedule-server --help When using Kubernetes , obtain a shell in a Sqedule pod: kubectl exec -ti deploy/sqedule -- sh The sqedule-server executable is in PATH so you can invoke from this shell: sqedule-server --help !!! note The container environment is Alpine.","title":"Invoking the Sqedule server executable"},{"location":"server_guide/concepts/server-exe/#subcommands","text":"To see what subcommands sqedule-server supports, run it with --help . You should see something like this: $ sqedule-server --help Sqedule server Usage: sqedule-server [command] Available Commands: db Manage the database help Help about any command run Run the Sqedule API server version Show server version Flags: --config string config file (default $HOME/.sqedule-server.yaml) -h, --help help for sqedule-server --log-level string log level, one of: error,warn,info,silent (default \"info\") Use \"sqedule-server [command] --help\" for more information about a command.","title":"Subcommands"},{"location":"server_guide/config/","text":"Configuration In this section: Ways to pass configuration Configuration naming format Configuration reference PostgreSQL connection string","title":"Configuration"},{"location":"server_guide/config/#configuration","text":"In this section: Ways to pass configuration Configuration naming format Configuration reference PostgreSQL connection string","title":"Configuration"},{"location":"server_guide/config/naming/","text":"Configuration naming format Configuration options have a canonical name , for example db-type . When using the configuration file, specify configuration options using their canonical names. Example: db-type: something When using environment variables, specify configuration options with the SQEDULE_ prefix, in uppercase, with dashes ( - ) replaced by underscores ( _ ). Example: SQEDULE_DB_TYPE=something When using CLI parameters, specify two dashes ( -- ) followed by the canonical name. Example: --db-type=something Caveat When setting a boolean option using a CLI parameter, be sure to specify the value after a = , like this: --something=true_or_false . Specifying the value after a space, like --something true_or_false doesn't work. Note The rest of the Server Guide only specifies configuration names in their canonical format.","title":"Naming format"},{"location":"server_guide/config/naming/#configuration-naming-format","text":"Configuration options have a canonical name , for example db-type . When using the configuration file, specify configuration options using their canonical names. Example: db-type: something When using environment variables, specify configuration options with the SQEDULE_ prefix, in uppercase, with dashes ( - ) replaced by underscores ( _ ). Example: SQEDULE_DB_TYPE=something When using CLI parameters, specify two dashes ( -- ) followed by the canonical name. Example: --db-type=something Caveat When setting a boolean option using a CLI parameter, be sure to specify the value after a = , like this: --something=true_or_false . Specifying the value after a space, like --something true_or_false doesn't work. Note The rest of the Server Guide only specifies configuration names in their canonical format.","title":"Configuration naming format"},{"location":"server_guide/config/postgresql/","text":"PostgreSQL connection string PostgreSQL connection strings can be in DSN format or in URL format. Examples: db-connection : user=jack password=secret host=pg.example.com port=5432 dbname=mydb sslmode=verify-ca db-connection : postgres://jack:secret@pg.example.com:5432/mydb?sslmode=verify-ca Sqedule also reads from PG* environment variables, and (if a password is not provided) from the .pgpass file. Therefore, providing a connection string is optional. Please refer to the PostgreSQL documentation on: Supported options in the connection string The meaning of PG* environment variables Note that Sqedule only supports these environment variables: PGHOST PGPORT PGDATABASE PGUSER PGPASSWORD PGPASSFILE PGSERVICE PGSERVICEFILE PGSSLMODE PGSSLCERT PGSSLKEY PGSSLROOTCERT PGAPPNAME PGCONNECT_TIMEOUT PGTARGETSESSIONATTRS","title":"PostgreSQL connection string"},{"location":"server_guide/config/postgresql/#postgresql-connection-string","text":"PostgreSQL connection strings can be in DSN format or in URL format. Examples: db-connection : user=jack password=secret host=pg.example.com port=5432 dbname=mydb sslmode=verify-ca db-connection : postgres://jack:secret@pg.example.com:5432/mydb?sslmode=verify-ca Sqedule also reads from PG* environment variables, and (if a password is not provided) from the .pgpass file. Therefore, providing a connection string is optional. Please refer to the PostgreSQL documentation on: Supported options in the connection string The meaning of PG* environment variables Note that Sqedule only supports these environment variables: PGHOST PGPORT PGDATABASE PGUSER PGPASSWORD PGPASSFILE PGSERVICE PGSERVICEFILE PGSSLMODE PGSSLCERT PGSSLKEY PGSSLROOTCERT PGAPPNAME PGCONNECT_TIMEOUT PGTARGETSESSIONATTRS","title":"PostgreSQL connection string"},{"location":"server_guide/config/reference/","text":"Configuration reference Global options All sqedule-server subcommands accept these configuration options: log-level (default: info ) \u2014 Specifies the logging level for most messages. Must be one of: error , warn , info or silent . run options The sqedule-server run subcommand accepts these configuration options. Database db-type (required) \u2014 The database type. Currently this can only be set to postgresql . db-connection (string) \u2014 Database connection string containing details such as location and credentials. The format is database-dependent. See PostgreSQL connection string . db-log-level (default: silent ) \u2014 Specifies the logging level for database activity messages. Must be one of: error , warn , info or silent . auto-db-migrate (boolean, default: true ) \u2014 Whether to automatically migrate the database schema during startup. HTTP server bind (string, default: localhost ) \u2014 The IP/hostname to bind on. port (integer, default: 3001 ) \u2014 The port to bind on. cors-origin (string) \u2014 Allow requests from the given CORS origin (e.g. https://yourhost.com ). Commands Sqedule to output CORS preflight responses that allow this origin.","title":"Reference"},{"location":"server_guide/config/reference/#configuration-reference","text":"","title":"Configuration reference"},{"location":"server_guide/config/reference/#global-options","text":"All sqedule-server subcommands accept these configuration options: log-level (default: info ) \u2014 Specifies the logging level for most messages. Must be one of: error , warn , info or silent .","title":"Global options"},{"location":"server_guide/config/reference/#run-options","text":"The sqedule-server run subcommand accepts these configuration options.","title":"run options"},{"location":"server_guide/config/reference/#database","text":"db-type (required) \u2014 The database type. Currently this can only be set to postgresql . db-connection (string) \u2014 Database connection string containing details such as location and credentials. The format is database-dependent. See PostgreSQL connection string . db-log-level (default: silent ) \u2014 Specifies the logging level for database activity messages. Must be one of: error , warn , info or silent . auto-db-migrate (boolean, default: true ) \u2014 Whether to automatically migrate the database schema during startup.","title":"Database"},{"location":"server_guide/config/reference/#http-server","text":"bind (string, default: localhost ) \u2014 The IP/hostname to bind on. port (integer, default: 3001 ) \u2014 The port to bind on. cors-origin (string) \u2014 Allow requests from the given CORS origin (e.g. https://yourhost.com ). Commands Sqedule to output CORS preflight responses that allow this origin.","title":"HTTP server"},{"location":"server_guide/config/ways/","text":"Ways to pass configuration There are 3 ways to pass configuration to the Sqedule server. 1. Config file You can pass configuration from the configuration file. This is recommended when you've installed the Sqedule server via the binary (without containerization) . The file is in YAML format. The Sqedule server looks for the configuration file in ~/.sqedule-server.yaml by default. You can customize the location by running the Sqedule server with --config /path-to-actual-file.yml . 2. Environment variables You can pass configuration from environment variables. This is recommended when you're using containerization or Kubernetes . 3. CLI parameters You can pass some configuration through CLI parameters when running the Sqedule server . Which CLI parameters are accepted depends on the specific subcommand. Caveat There's a caveat with setting boolean options through CLI parameters. Learn more in Configuration naming format . Precedence Configuration is loaded in the given order (least to most important): Config file Environment variables CLI parameters CLI parameters override environment variables. Environment variables override the configuration file.","title":"Ways to pass configuration"},{"location":"server_guide/config/ways/#ways-to-pass-configuration","text":"There are 3 ways to pass configuration to the Sqedule server.","title":"Ways to pass configuration"},{"location":"server_guide/config/ways/#1-config-file","text":"You can pass configuration from the configuration file. This is recommended when you've installed the Sqedule server via the binary (without containerization) . The file is in YAML format. The Sqedule server looks for the configuration file in ~/.sqedule-server.yaml by default. You can customize the location by running the Sqedule server with --config /path-to-actual-file.yml .","title":"1. Config file"},{"location":"server_guide/config/ways/#2-environment-variables","text":"You can pass configuration from environment variables. This is recommended when you're using containerization or Kubernetes .","title":"2. Environment variables"},{"location":"server_guide/config/ways/#3-cli-parameters","text":"You can pass some configuration through CLI parameters when running the Sqedule server . Which CLI parameters are accepted depends on the specific subcommand. Caveat There's a caveat with setting boolean options through CLI parameters. Learn more in Configuration naming format .","title":"3. CLI parameters"},{"location":"server_guide/config/ways/#precedence","text":"Configuration is loaded in the given order (least to most important): Config file Environment variables CLI parameters CLI parameters override environment variables. Environment variables override the configuration file.","title":"Precedence"},{"location":"server_guide/installation/binary/","text":"Installation with the binary (without containerization) 1. Create user account Create a user account to run the Sqedule server in. For example: sudo addgroup --gid 3420 sqedule-server sudo adduser --uid 3420 --gid 3420 --disabled-password --gecos 'Sqedule Server' sqedule-server 2. Download Download a Sqedule server binary tarball ( sqedule-server-XXX-linux-x86_64.tar.gz ). Extract the tarball. There's a sqedule-server executable inside. Check whether it works: /path-to/sqedule-server --help 3. Create config file Create a Sqedule server configuration file /etc/sqedule-server.yml . Learn more in Configuration . At minimum you need to configure the database type and credentials. Example: db-type : postgresql db-connection : 'dbname=sqedule user=sqedule password=something host=localhost port=5432' Be sure to give the file the right permissions so that the database password cannot be read by others: sudo chown sqedule-server: /etc/sqedule-server.yml sudo chmod 600 /etc/sqedule-server.yml 4. Install systemd service Install a systemd service file. Create /etc/systemd/system/sqedule-server.service: [Unit] Description = Sqedule Server [Service] ExecStart = /path-to/sqedule-server run --config=/etc/sqedule-server.yml User = sqedule-server PrivateTmp = true [Install] WantedBy = multi-user.target Note Be sure to replace /path-to/sqedule-server with the actual path! Then reload systemd: sudo systemctl daemon-reload 5. Start Sqedule server Start the Sqedule server: sudo systemctl start sqedule-server Note You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup . It listens on localhost port 3001 by default. Try it out, you should see the web interface's HTML: curl localhost:3001 Next up Now that it's installed, please be aware of the security considerations .","title":"With binary (no container)"},{"location":"server_guide/installation/binary/#installation-with-the-binary-without-containerization","text":"","title":"Installation with the binary (without containerization)"},{"location":"server_guide/installation/binary/#1-create-user-account","text":"Create a user account to run the Sqedule server in. For example: sudo addgroup --gid 3420 sqedule-server sudo adduser --uid 3420 --gid 3420 --disabled-password --gecos 'Sqedule Server' sqedule-server","title":"1. Create user account"},{"location":"server_guide/installation/binary/#2-download","text":"Download a Sqedule server binary tarball ( sqedule-server-XXX-linux-x86_64.tar.gz ). Extract the tarball. There's a sqedule-server executable inside. Check whether it works: /path-to/sqedule-server --help","title":"2. Download"},{"location":"server_guide/installation/binary/#3-create-config-file","text":"Create a Sqedule server configuration file /etc/sqedule-server.yml . Learn more in Configuration . At minimum you need to configure the database type and credentials. Example: db-type : postgresql db-connection : 'dbname=sqedule user=sqedule password=something host=localhost port=5432' Be sure to give the file the right permissions so that the database password cannot be read by others: sudo chown sqedule-server: /etc/sqedule-server.yml sudo chmod 600 /etc/sqedule-server.yml","title":"3. Create config file"},{"location":"server_guide/installation/binary/#4-install-systemd-service","text":"Install a systemd service file. Create /etc/systemd/system/sqedule-server.service: [Unit] Description = Sqedule Server [Service] ExecStart = /path-to/sqedule-server run --config=/etc/sqedule-server.yml User = sqedule-server PrivateTmp = true [Install] WantedBy = multi-user.target Note Be sure to replace /path-to/sqedule-server with the actual path! Then reload systemd: sudo systemctl daemon-reload","title":"4. Install systemd service"},{"location":"server_guide/installation/binary/#5-start-sqedule-server","text":"Start the Sqedule server: sudo systemctl start sqedule-server Note You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup . It listens on localhost port 3001 by default. Try it out, you should see the web interface's HTML: curl localhost:3001","title":"5. Start Sqedule server"},{"location":"server_guide/installation/binary/#next-up","text":"Now that it's installed, please be aware of the security considerations .","title":"Next up"},{"location":"server_guide/installation/container/","text":"Installation with container Use the image ghcr.io/fullstaq-labs/sqedule-server . You must pass configuration via environment variables. Learn more in Configuration . At minimum you need to configure the database type and credentials. Inside the container, the Sqedule server listens on port 3001. You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup. Example: docker run --rm \\ -p 3001 :3001 \\ -e SQEDULE_DB_TYPE = postgresql \\ -e SQEDULE_DB_CONNECTION = 'dbname=sqedule user=sqedule password=something host=localhost port=5432' \\ ghcr.io/fullstaq-labs/sqedule-server Try it out, you should see the web interface's HTML: curl localhost:3001 Next up Now that it's installed, please be aware of the security considerations .","title":"With container"},{"location":"server_guide/installation/container/#installation-with-container","text":"Use the image ghcr.io/fullstaq-labs/sqedule-server . You must pass configuration via environment variables. Learn more in Configuration . At minimum you need to configure the database type and credentials. Inside the container, the Sqedule server listens on port 3001. You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup. Example: docker run --rm \\ -p 3001 :3001 \\ -e SQEDULE_DB_TYPE = postgresql \\ -e SQEDULE_DB_CONNECTION = 'dbname=sqedule user=sqedule password=something host=localhost port=5432' \\ ghcr.io/fullstaq-labs/sqedule-server Try it out, you should see the web interface's HTML: curl localhost:3001","title":"Installation with container"},{"location":"server_guide/installation/container/#next-up","text":"Now that it's installed, please be aware of the security considerations .","title":"Next up"},{"location":"server_guide/installation/kubernetes/","text":"Installation with Kubernetes 1. Create Secret Create a secret containing the database location and credentials. First, create a database connection string and encode it as Base64. For example: echo -n 'dbname=sqedule user=sqedule password=something host=localhost port=5432' | base64 Then create a Kubernetes Secret: apiVersion : v1 kind : Secret metadata : name : sqedule-db-connection type : Opaque data : db_connection : <BASE64 DATA HERE> 2. Create Deployment Create a Kubernetes Deployment. You must pass configuration via environment variables. Learn more in Configuration . At minimum you need to configure the database type and credentials. You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup . Sqedule in its default configuration does not support running multiple instances. Therefore, unless you've taken steps to make Sqedule multi-instance-safe , you must only run a single replica and you must only use the recreate update strategy. Example: apiVersion : apps/v1 kind : Deployment metadata : name : sqedule labels : app : sqedule spec : selector : matchLabels : app : sqedule strategy : type : recreate template : metadata : labels : app : sqedule spec : containers : - name : sqedule image : ghcr.io/fullstaq-labs/sqedule-server ports : - containerPort : 3001 env : - name : SQEDULE_DB_TYPE value : postgresql - name : SQEDULE_DB_CONNECTION valueFrom : secretKeyRef : name : sqedule-db-connection key : db_connection 3. Create Service Create a Kubernetes Service so that the Sqedule server can be accessed through the network. apiVersion : v1 kind : Service metadata : name : sqedule spec : selector : app : sqedule ports : - protocol : TCP port : 80 targetPort : 3001 Next up Now that it's installed, please be aware of the security considerations .","title":"With Kubernetes"},{"location":"server_guide/installation/kubernetes/#installation-with-kubernetes","text":"","title":"Installation with Kubernetes"},{"location":"server_guide/installation/kubernetes/#1-create-secret","text":"Create a secret containing the database location and credentials. First, create a database connection string and encode it as Base64. For example: echo -n 'dbname=sqedule user=sqedule password=something host=localhost port=5432' | base64 Then create a Kubernetes Secret: apiVersion : v1 kind : Secret metadata : name : sqedule-db-connection type : Opaque data : db_connection : <BASE64 DATA HERE>","title":"1. Create Secret"},{"location":"server_guide/installation/kubernetes/#2-create-deployment","text":"Create a Kubernetes Deployment. You must pass configuration via environment variables. Learn more in Configuration . At minimum you need to configure the database type and credentials. You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup . Sqedule in its default configuration does not support running multiple instances. Therefore, unless you've taken steps to make Sqedule multi-instance-safe , you must only run a single replica and you must only use the recreate update strategy. Example: apiVersion : apps/v1 kind : Deployment metadata : name : sqedule labels : app : sqedule spec : selector : matchLabels : app : sqedule strategy : type : recreate template : metadata : labels : app : sqedule spec : containers : - name : sqedule image : ghcr.io/fullstaq-labs/sqedule-server ports : - containerPort : 3001 env : - name : SQEDULE_DB_TYPE value : postgresql - name : SQEDULE_DB_CONNECTION valueFrom : secretKeyRef : name : sqedule-db-connection key : db_connection","title":"2. Create Deployment"},{"location":"server_guide/installation/kubernetes/#3-create-service","text":"Create a Kubernetes Service so that the Sqedule server can be accessed through the network. apiVersion : v1 kind : Service metadata : name : sqedule spec : selector : app : sqedule ports : - protocol : TCP port : 80 targetPort : 3001","title":"3. Create Service"},{"location":"server_guide/installation/kubernetes/#next-up","text":"Now that it's installed, please be aware of the security considerations .","title":"Next up"},{"location":"server_guide/installation/requirements/","text":"Installation requirements Database The Sqedule server requires PostgreSQL >= 13. Other databases may be supported in the future depending on user demand. The PostgreSQL instance must have the citext extension installed. Schemas You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup . Permissions When the Sqedule server migrates the database schema, it will enable the citext extension. Since PostgreSQL 13, the citext extension is by default considered a trusted extension, and so anybody can enable it. Everything should work by default. On older PostgreSQL versions, enabling the extension may result in this error: ERROR: permission denied to create extension \"citext\" HINT: Must be superuser to create this extension. You can do one of the following to make it work: Let a superuser role pre-enable the citext extension on the Sqedule database. CREATE EXTENSION citext ; -OR-: The PostgreSQL user that the Sqedule server authenticates with, must have the superuser role. Operating system In theory, the server can be run on all operating systems that the Go programming language supports. But we've only tested on macOS and Linux, and we only provide precompiled binaries for Linux (x86_64).","title":"Requirements"},{"location":"server_guide/installation/requirements/#installation-requirements","text":"","title":"Installation requirements"},{"location":"server_guide/installation/requirements/#database","text":"The Sqedule server requires PostgreSQL >= 13. Other databases may be supported in the future depending on user demand. The PostgreSQL instance must have the citext extension installed.","title":"Database"},{"location":"server_guide/installation/requirements/#schemas","text":"You don't need to manually setup database schemas. The Sqedule server takes care of that automatically during startup .","title":"Schemas"},{"location":"server_guide/installation/requirements/#permissions","text":"When the Sqedule server migrates the database schema, it will enable the citext extension. Since PostgreSQL 13, the citext extension is by default considered a trusted extension, and so anybody can enable it. Everything should work by default. On older PostgreSQL versions, enabling the extension may result in this error: ERROR: permission denied to create extension \"citext\" HINT: Must be superuser to create this extension. You can do one of the following to make it work: Let a superuser role pre-enable the citext extension on the Sqedule database. CREATE EXTENSION citext ; -OR-: The PostgreSQL user that the Sqedule server authenticates with, must have the superuser role.","title":"Permissions"},{"location":"server_guide/installation/requirements/#operating-system","text":"In theory, the server can be run on all operating systems that the Go programming language supports. But we've only tested on macOS and Linux, and we only provide precompiled binaries for Linux (x86_64).","title":"Operating system"},{"location":"server_guide/tasks/disabling-automatic-schema-migration/","text":"Disabling automatic schema migration You may want to disable automatic database schema migration in order to make the Sqedule server multi-instance safe . To disable, set the configuration option auto-db-migrate to false. Warning If you disable automatic database schema migration, then you become responsible for running database schema migrations manually every time you upgrade the Sqedule server.","title":"Disabling automatic schema migration"},{"location":"server_guide/tasks/disabling-automatic-schema-migration/#disabling-automatic-schema-migration","text":"You may want to disable automatic database schema migration in order to make the Sqedule server multi-instance safe . To disable, set the configuration option auto-db-migrate to false. Warning If you disable automatic database schema migration, then you become responsible for running database schema migrations manually every time you upgrade the Sqedule server.","title":"Disabling automatic schema migration"},{"location":"server_guide/tasks/manual-database-schema-migration/","text":"Manually migrating the database schema By default, the Sqedule server automatically migrates the database schema during startup. Sometimes you may want to migrate the schema manually: You've disabled automatic database schema migration . You want to downgrade Sqedule to a previous version, and thus you need to rollback to a previous schema version. Note Schema migration may require sufficient permissions . Upgrading the database schema Invoke the subcommand sqedule-server db migrate . This subcommand requires the following configuration options : db-type db-connection Example: sqedule-server db migrate --db-type postgresql --db-connection 'dbname=sqedule user=sqedule password=something host=localhost port=5432' Rolling back the database schema Invoke the subcommand sqedule-server db rollback . This subcommand requires the following configuration options . db-type db-connection target (string) \u2014 The schema version to rollback to. This is something like \"20210304000010 Release approval ruleset binding\". Example: sqedule-server db rollback \\ --db-type postgresql \\ --db-connection 'dbname=sqedule user=sqedule password=something host=localhost port=5432' \\ --target '20210304000010 Release approval ruleset binding' Available schema target names You can find out the available schema target names by inspecting the Sqedule server's source code . Look in the subdirectory server/dbmigrations and you'll see files like these: 20201021000000_basic_settings.go ... 20210304000010_release_approval_ruleset_binding.go Each one of these files is a schema target. To find out the name of a specific target, look inside the file and look for ID: \"something\" . For example in 20210304000010_release_approval_ruleset_binding.go : var migration20210304000010 = gormigrate . Migration { ID : \"20210304000010 Release approval ruleset binding\" , ... } Here we see that the target name is \"20210304000010 Release approval ruleset binding\". Determining the schema target name for a previous Sqedule release Visit Sqedule's Github repository . Click on Github's branch/tag dropdown, and select the tag for the Sqedule server version that you want to rollback the schema to. Browse to the subdirectory server/dbmigrations . Look inside the last migration file in the directory. The ID inside that file is the schema target name you're looking for.","title":"Manually migrating the database schema"},{"location":"server_guide/tasks/manual-database-schema-migration/#manually-migrating-the-database-schema","text":"By default, the Sqedule server automatically migrates the database schema during startup. Sometimes you may want to migrate the schema manually: You've disabled automatic database schema migration . You want to downgrade Sqedule to a previous version, and thus you need to rollback to a previous schema version. Note Schema migration may require sufficient permissions .","title":"Manually migrating the database schema"},{"location":"server_guide/tasks/manual-database-schema-migration/#upgrading-the-database-schema","text":"Invoke the subcommand sqedule-server db migrate . This subcommand requires the following configuration options : db-type db-connection Example: sqedule-server db migrate --db-type postgresql --db-connection 'dbname=sqedule user=sqedule password=something host=localhost port=5432'","title":"Upgrading the database schema"},{"location":"server_guide/tasks/manual-database-schema-migration/#rolling-back-the-database-schema","text":"Invoke the subcommand sqedule-server db rollback . This subcommand requires the following configuration options . db-type db-connection target (string) \u2014 The schema version to rollback to. This is something like \"20210304000010 Release approval ruleset binding\". Example: sqedule-server db rollback \\ --db-type postgresql \\ --db-connection 'dbname=sqedule user=sqedule password=something host=localhost port=5432' \\ --target '20210304000010 Release approval ruleset binding'","title":"Rolling back the database schema"},{"location":"server_guide/tasks/manual-database-schema-migration/#available-schema-target-names","text":"You can find out the available schema target names by inspecting the Sqedule server's source code . Look in the subdirectory server/dbmigrations and you'll see files like these: 20201021000000_basic_settings.go ... 20210304000010_release_approval_ruleset_binding.go Each one of these files is a schema target. To find out the name of a specific target, look inside the file and look for ID: \"something\" . For example in 20210304000010_release_approval_ruleset_binding.go : var migration20210304000010 = gormigrate . Migration { ID : \"20210304000010 Release approval ruleset binding\" , ... } Here we see that the target name is \"20210304000010 Release approval ruleset binding\".","title":"Available schema target names"},{"location":"server_guide/tasks/manual-database-schema-migration/#determining-the-schema-target-name-for-a-previous-sqedule-release","text":"Visit Sqedule's Github repository . Click on Github's branch/tag dropdown, and select the tag for the Sqedule server version that you want to rollback the schema to. Browse to the subdirectory server/dbmigrations . Look inside the last migration file in the directory. The ID inside that file is the schema target name you're looking for.","title":"Determining the schema target name for a previous Sqedule release"},{"location":"server_guide/tasks/multi-instance/","text":"Running multiple server instances See also Concept: Multi-instance safety To make it safe to run multiple concurrent instances of the Sqedule server, disable automatic database schema migration .","title":"Running multiple server instances"},{"location":"server_guide/tasks/multi-instance/#running-multiple-server-instances","text":"See also Concept: Multi-instance safety To make it safe to run multiple concurrent instances of the Sqedule server, disable automatic database schema migration .","title":"Running multiple server instances"},{"location":"user_guide/","text":"Introduction This User Guide teaches you how to use Sqedule . It assumes that you already have a Sqedule server installed (see the Server Guide ). Made with \u2764\ufe0f by Fullstaq Sqedule is made by Fullstaq. Learn more .","title":"Introduction"},{"location":"user_guide/#introduction","text":"This User Guide teaches you how to use Sqedule . It assumes that you already have a Sqedule server installed (see the Server Guide ).","title":"Introduction"},{"location":"user_guide/#made-with-by-fullstaq","text":"Sqedule is made by Fullstaq. Learn more .","title":"Made with \u2764\ufe0f&nbsp; by Fullstaq"},{"location":"user_guide/help_support/","text":"Help & support To report bugs or request features, please visit the issue tracker . To ask questions or to discuss things, please visit the discussion forum .","title":"Help & support"},{"location":"user_guide/help_support/#help-support","text":"To report bugs or request features, please visit the issue tracker . To ask questions or to discuss things, please visit the discussion forum .","title":"Help &amp; support"},{"location":"user_guide/concepts/api/","text":"API The Sqedule server provides an HTTP JSON API. Both the web interface and the CLI make use of the API. There is currently no authentication because the server does not support that yet , although the server administrator can choose put to Sqedule behind a reverse proxy that puts up HTTP Basic Authentication. See also API endpoints","title":"API"},{"location":"user_guide/concepts/api/#api","text":"The Sqedule server provides an HTTP JSON API. Both the web interface and the CLI make use of the API. There is currently no authentication because the server does not support that yet , although the server administrator can choose put to Sqedule behind a reverse proxy that puts up HTTP Basic Authentication.","title":"API"},{"location":"user_guide/concepts/api/#see-also","text":"API endpoints","title":"See also"},{"location":"user_guide/concepts/applications-releases/","text":"Applications & releases One defines applications in Sqedule. Sqedule then tracks the releases that have occurred for those applications. An \"application\" in Sqedule represents an entity for which releases can exist. So it doesn't have to be an actual application: it could be a part of an application, it could be a logical group of applications, or it could be anything else as long as it's releasable. A \"release\" tracks a single release. When a releaser (for example a CD pipeline) wants start a release process, it first registers a new release in Sqedule. This release starts in the \"pending\" state. Sqedule then optionally evaluates approval rules on this release. Depending on the outcomes of the rule evaluations, Sqedule may approve or reject this release. When the releaser notices this state change, it either aborts or proceeds with the release process. An application groups multiple releases. Each release may be in the \"pending\", \"approved\" or \"rejected\" state. The CD pipeline registers a release, and waits until it's approved or rejected before proceeding.","title":"Applications & releases"},{"location":"user_guide/concepts/applications-releases/#applications-releases","text":"One defines applications in Sqedule. Sqedule then tracks the releases that have occurred for those applications. An \"application\" in Sqedule represents an entity for which releases can exist. So it doesn't have to be an actual application: it could be a part of an application, it could be a logical group of applications, or it could be anything else as long as it's releasable. A \"release\" tracks a single release. When a releaser (for example a CD pipeline) wants start a release process, it first registers a new release in Sqedule. This release starts in the \"pending\" state. Sqedule then optionally evaluates approval rules on this release. Depending on the outcomes of the rule evaluations, Sqedule may approve or reject this release. When the releaser notices this state change, it either aborts or proceeds with the release process. An application groups multiple releases. Each release may be in the \"pending\", \"approved\" or \"rejected\" state. The CD pipeline registers a release, and waits until it's approved or rejected before proceeding.","title":"Applications &amp; releases"},{"location":"user_guide/concepts/approval-rules/","text":"Approval rules When a release is created, Sqedule evaluates rules on that release. Depending on the outcomes of these evaluations, Sqedule may approve or reject a release. Rules are grouped in rulesets . Rulesets must be bound to applications. When a release is created, Sqedule only approves the rules for rulesets bound to the corresponding application. A ruleset binding can be in one of two modes: Enforcing \u2014 If a rule evaluates as failed, then the release is rejected. Permissive \u2014 If a rule evaluates as failed, then this failure is logged, but the release is not rejected. Sqedule rejects a release if at least one rule evaluates as failed, and that rule is bound in enforcing mode. Otherwise, the release is approved. This means that if there are no rules bound to an application, then new releases are always approved. Rulesets group multiple rules. Applications are bound to rulesets via bindings. A binding can be in enforcing or permissive mode. Rule types At present, Sqedule only supports one type of rule: the so-called \"schedule rule\". More rule types will be supported in the future as Sqedule receives further development. Schedule rules A Schedule rule defines a time-of-day window in which releases are allowed.","title":"Approval rules"},{"location":"user_guide/concepts/approval-rules/#approval-rules","text":"When a release is created, Sqedule evaluates rules on that release. Depending on the outcomes of these evaluations, Sqedule may approve or reject a release. Rules are grouped in rulesets . Rulesets must be bound to applications. When a release is created, Sqedule only approves the rules for rulesets bound to the corresponding application. A ruleset binding can be in one of two modes: Enforcing \u2014 If a rule evaluates as failed, then the release is rejected. Permissive \u2014 If a rule evaluates as failed, then this failure is logged, but the release is not rejected. Sqedule rejects a release if at least one rule evaluates as failed, and that rule is bound in enforcing mode. Otherwise, the release is approved. This means that if there are no rules bound to an application, then new releases are always approved. Rulesets group multiple rules. Applications are bound to rulesets via bindings. A binding can be in enforcing or permissive mode.","title":"Approval rules"},{"location":"user_guide/concepts/approval-rules/#rule-types","text":"At present, Sqedule only supports one type of rule: the so-called \"schedule rule\". More rule types will be supported in the future as Sqedule receives further development.","title":"Rule types"},{"location":"user_guide/concepts/approval-rules/#schedule-rules","text":"A Schedule rule defines a time-of-day window in which releases are allowed.","title":"Schedule rules"},{"location":"user_guide/concepts/cli/","text":"About the CLI We provide a CLI for viewing and manipulating resources in the Sqedule server. It is an alternative to the web interface . Under the hood, the CLI makes use the of API , so if you feel adventurous enough you can also just use the API directly. The CLI supports all operating systems that the Go programming language supports, but we only provide precompiled binaries for macOS (x86_64, M1) Windows (x86_64) and Linux (x86_64). Subcommands The CLI supports multiple subcommands, similar to how Git works. You can view a list of all subcommands by running sqedule --help . It should look similar to this: Sqedule client CLI Usage: sqedule [command] Available Commands: application Manage applications application-approval-ruleset-binding Manage application approval ruleset bindings approval-ruleset Manage approval rulesets help Help about any command release Manage releases version Show CLI version Flags: --config string config file (default ~/.config/sqedule-cli/config.yml) --debug show API requests/responses -h, --help help for sqedule Use \"sqedule [command] --help\" for more information about a command. See also The tutorials , which demonstrate the use of the CLI Installing the CLI Initial CLI setup CLI configuration reference","title":"CLI"},{"location":"user_guide/concepts/cli/#about-the-cli","text":"We provide a CLI for viewing and manipulating resources in the Sqedule server. It is an alternative to the web interface . Under the hood, the CLI makes use the of API , so if you feel adventurous enough you can also just use the API directly. The CLI supports all operating systems that the Go programming language supports, but we only provide precompiled binaries for macOS (x86_64, M1) Windows (x86_64) and Linux (x86_64).","title":"About the CLI"},{"location":"user_guide/concepts/cli/#subcommands","text":"The CLI supports multiple subcommands, similar to how Git works. You can view a list of all subcommands by running sqedule --help . It should look similar to this: Sqedule client CLI Usage: sqedule [command] Available Commands: application Manage applications application-approval-ruleset-binding Manage application approval ruleset bindings approval-ruleset Manage approval rulesets help Help about any command release Manage releases version Show CLI version Flags: --config string config file (default ~/.config/sqedule-cli/config.yml) --debug show API requests/responses -h, --help help for sqedule Use \"sqedule [command] --help\" for more information about a command.","title":"Subcommands"},{"location":"user_guide/concepts/cli/#see-also","text":"The tutorials , which demonstrate the use of the CLI Installing the CLI Initial CLI setup CLI configuration reference","title":"See also"},{"location":"user_guide/concepts/versioning/","text":"Versioning, proposals & reviews Many resources in Sqedule are versioned . This has several reasons: History \u2014 so that you can always revert back to a previous version in case something goes wrong. Auditing \u2014 logging all changes so that you know why something changed, and who were responsible. Reviewing \u2014 don't activate changes until they are reviewed. Concurrency management \u2014 preventing data modifications from interfering with on-going, long-running processes. Such processes use the data versions from when the processes begun, not the latest versions. For example, approval rulesets are versioned. But when Sqedule starts evaluating rules on a release (which can take a while), concurrent modifications on rulesets have no effect on the rule evaluation process: Sqedule evaluates against the ruleset versions that existed when the release was created. Versioned resources version most of their data, but not all. For example, resource IDs are never versioned. Lifecycle A version starts as a proposal (meaning it's unapproved) and may later become approved , rejected or abandoned . Proposal lifecycle. For brevity, the \"rejected\" version state is omitted. Proposals have no effect and can be modified at will. A proposal starts as a draft . Once the author(s) of a proposal are satisfied, they can finalize the proposal. Upon finalization, Sqedule determines whether the proposal is eligible for automatic approval. Automatic approval applies when Sqedule determines that approving the proposal is safe because it does not change system behavior. If the proposal is not eligible for automatic approval, then Sqedule forwards the proposal to change managers to manually review . A rejected proposal may be modified and refinalized. An unapproved proposal may be abandoned at any time. An abandoned proposal may be reopened at any time. Only the \"approved\" state is final. Relationship with JSON API output To understand the relationship between the versioning concept and the JSON API output (which is also outputted by the CLI ), let's take a look at the following example which shows the JSON representation of an application . { \"approval_ruleset_bindings\" : [], \"id\" : \"shopping_cart_service\" , // (1) \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , // (1) \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" , // (1) \"latest_approved_version\" : { // (2) \"proposal_state\" : \"approved\" , // (3) \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , // (4) \"enabled\" : true , // (4) \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" // (3) } } Non-versioned data is located in the top-level JSON object. Versioned data, as well as versioning state, is located in latest_approved_version (or in some other JSON outputs, version ). The version state and proposal state are shown here. These are the versioned data.","title":"Versioning, proposals & reviews"},{"location":"user_guide/concepts/versioning/#versioning-proposals-reviews","text":"Many resources in Sqedule are versioned . This has several reasons: History \u2014 so that you can always revert back to a previous version in case something goes wrong. Auditing \u2014 logging all changes so that you know why something changed, and who were responsible. Reviewing \u2014 don't activate changes until they are reviewed. Concurrency management \u2014 preventing data modifications from interfering with on-going, long-running processes. Such processes use the data versions from when the processes begun, not the latest versions. For example, approval rulesets are versioned. But when Sqedule starts evaluating rules on a release (which can take a while), concurrent modifications on rulesets have no effect on the rule evaluation process: Sqedule evaluates against the ruleset versions that existed when the release was created. Versioned resources version most of their data, but not all. For example, resource IDs are never versioned.","title":"Versioning, proposals &amp; reviews"},{"location":"user_guide/concepts/versioning/#lifecycle","text":"A version starts as a proposal (meaning it's unapproved) and may later become approved , rejected or abandoned . Proposal lifecycle. For brevity, the \"rejected\" version state is omitted. Proposals have no effect and can be modified at will. A proposal starts as a draft . Once the author(s) of a proposal are satisfied, they can finalize the proposal. Upon finalization, Sqedule determines whether the proposal is eligible for automatic approval. Automatic approval applies when Sqedule determines that approving the proposal is safe because it does not change system behavior. If the proposal is not eligible for automatic approval, then Sqedule forwards the proposal to change managers to manually review . A rejected proposal may be modified and refinalized. An unapproved proposal may be abandoned at any time. An abandoned proposal may be reopened at any time. Only the \"approved\" state is final.","title":"Lifecycle"},{"location":"user_guide/concepts/versioning/#relationship-with-json-api-output","text":"To understand the relationship between the versioning concept and the JSON API output (which is also outputted by the CLI ), let's take a look at the following example which shows the JSON representation of an application . { \"approval_ruleset_bindings\" : [], \"id\" : \"shopping_cart_service\" , // (1) \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , // (1) \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" , // (1) \"latest_approved_version\" : { // (2) \"proposal_state\" : \"approved\" , // (3) \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , // (4) \"enabled\" : true , // (4) \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" // (3) } } Non-versioned data is located in the top-level JSON object. Versioned data, as well as versioning state, is located in latest_approved_version (or in some other JSON outputs, version ). The version state and proposal state are shown here. These are the versioned data.","title":"Relationship with JSON API output"},{"location":"user_guide/concepts/web-interface/","text":"Web interface The Sqedule server provides a web interface. To view this, visit the server's base URL. The web interface is currently very basic. You can only view resources. To add, update or delete resources, use the CLI and API .","title":"Web interface"},{"location":"user_guide/concepts/web-interface/#web-interface","text":"The Sqedule server provides a web interface. To view this, visit the server's base URL. The web interface is currently very basic. You can only view resources. To add, update or delete resources, use the CLI and API .","title":"Web interface"},{"location":"user_guide/references/api-endpoints/","text":"API endpoints See also Concept: API Base URL All URL endpoints in this document are to be prefixed with the Sqedule server's base URL, plus the versioning prefix /v1 . For example if this document speaks of /releases , then the API endpoint is https://your-sqedule-server.com/v1/releases . Authentication There is currently no authentication because the server does not support that yet . But the server administrator is allowed to put the server behind a reverse proxy with HTTP Basic Authentication. Common error codes 400 Bad Request \u2014 A path parameter or the input body has a syntax error. 401 Unauthorized \u2014 Either an authentication failure, or the authenticated organization member is not authorized to perform this action. 404 Not Found \u2014 Resource not found. 500 Internal Server Error \u2014 Generic internal error. Types Most types are self-explanatory, but these types deserve further explanation: Timestamp \u2014 String in the format of \"2021-05-07T12:44:59.105536+02:00\". Releases Create release POST /applications/:application_id/releases Path parameters: application_id \u2014 ID of the application to create a release for. Input body: { /****** Optional fields ******/ // Arbitrary string that identifies the source location of this application, // for example the Git repo URL. Currently only used for display purposes, // but planned to have a semantic meaning in the future. \"source_identity\" : string , // Arbitrary metadata to include in this release. \"metadata\" : object , // Arbitrary comments to include in this release. \"comments\" : string , } Response codes: 201 Created \u2014 Creation success. List releases GET /applications/:application_id/releases Path parameters: application_id \u2014 ID of the application to list releases for. Get a release GET /applications/:application_id/releases/:id Path parameters: application_id \u2014 ID of the application to read a release for. id \u2014 ID of the release to read. Output body: { \"id\" : nu mber , \"state\" : \"pending\" | \"approved\" | \"rejected\" , \"source_identity\" : s tr i n g | null , \"metadata\" : objec t , \"comments\" : s tr i n g | null , \"created_at\" : t imes ta mp , \"updated_at\" : t imes ta mp , \"finalized_at\" : t imes ta mp | null , \"approval_ruleset_bindings\" : [ array o f Release Approval Rulese t Bi n di n gs ] }","title":"API endpoints"},{"location":"user_guide/references/api-endpoints/#api-endpoints","text":"See also Concept: API","title":"API endpoints"},{"location":"user_guide/references/api-endpoints/#base-url","text":"All URL endpoints in this document are to be prefixed with the Sqedule server's base URL, plus the versioning prefix /v1 . For example if this document speaks of /releases , then the API endpoint is https://your-sqedule-server.com/v1/releases .","title":"Base URL"},{"location":"user_guide/references/api-endpoints/#authentication","text":"There is currently no authentication because the server does not support that yet . But the server administrator is allowed to put the server behind a reverse proxy with HTTP Basic Authentication.","title":"Authentication"},{"location":"user_guide/references/api-endpoints/#common-error-codes","text":"400 Bad Request \u2014 A path parameter or the input body has a syntax error. 401 Unauthorized \u2014 Either an authentication failure, or the authenticated organization member is not authorized to perform this action. 404 Not Found \u2014 Resource not found. 500 Internal Server Error \u2014 Generic internal error.","title":"Common error codes"},{"location":"user_guide/references/api-endpoints/#types","text":"Most types are self-explanatory, but these types deserve further explanation: Timestamp \u2014 String in the format of \"2021-05-07T12:44:59.105536+02:00\".","title":"Types"},{"location":"user_guide/references/api-endpoints/#releases","text":"","title":"Releases"},{"location":"user_guide/references/api-endpoints/#create-release","text":"POST /applications/:application_id/releases Path parameters: application_id \u2014 ID of the application to create a release for. Input body: { /****** Optional fields ******/ // Arbitrary string that identifies the source location of this application, // for example the Git repo URL. Currently only used for display purposes, // but planned to have a semantic meaning in the future. \"source_identity\" : string , // Arbitrary metadata to include in this release. \"metadata\" : object , // Arbitrary comments to include in this release. \"comments\" : string , } Response codes: 201 Created \u2014 Creation success.","title":"Create release"},{"location":"user_guide/references/api-endpoints/#list-releases","text":"GET /applications/:application_id/releases Path parameters: application_id \u2014 ID of the application to list releases for.","title":"List releases"},{"location":"user_guide/references/api-endpoints/#get-a-release","text":"GET /applications/:application_id/releases/:id Path parameters: application_id \u2014 ID of the application to read a release for. id \u2014 ID of the release to read. Output body: { \"id\" : nu mber , \"state\" : \"pending\" | \"approved\" | \"rejected\" , \"source_identity\" : s tr i n g | null , \"metadata\" : objec t , \"comments\" : s tr i n g | null , \"created_at\" : t imes ta mp , \"updated_at\" : t imes ta mp , \"finalized_at\" : t imes ta mp | null , \"approval_ruleset_bindings\" : [ array o f Release Approval Rulese t Bi n di n gs ] }","title":"Get a release"},{"location":"user_guide/references/cli-config/","text":"CLI configuration reference See also Concept: CLI Ways to pass configuration There are 3 ways to pass configuration to the CLI. Configuration file . It's located in ~/.sqedule-cli.yaml by default. You can customize the location by running the CLI with --config /path-to-actual-file.yml . Environment variables . In some CI/CD pipelines, it's more convenient to set environment variables than to set CLI parameters. The tutorials demonstrate passing configuration via environment variables in the CI/CD pipeline. CLI parameters . Naming format Configuration options have a canonical name , for example server-base-url . When using the configuration file, specify configuration options using their canonical names. Example: server-base-url: https://your-sqedule-server.com When using environment variables, specify configuration options with the SQEDULE_ prefix, in uppercase, with dashes ( - ) replaced by underscores ( _ ). Example: SQEDULE_SERVER_BASE_URL: https://your-sqedule-server.com When using CLI parameters, specify two dashes ( -- ) followed by the canonical name. Example: --server-base-url=something Caveat When setting a boolean option using a CLI parameter, be sure to specify the value after a = , like this: --something=true_or_false . Specifying the value after a space, like --something true_or_false doesn't work. Note The rest of the User Guide only specifies configuration names in their canonical format. Precedence Configuration is loaded in the given order (least to most important): Config file Environment variables CLI parameters CLI parameters override environment variables. Environment variables override the configuration file. Global options These options apply to all subcommands. server-base-url (string, required) \u2014 The base URL of the Sqedule server to use. Example: https://your-sqedule-server.com basic-auth-user (string) \u2014 If the Sqedule server is protected by HTTP basic authentication, then specify the username here. basic-auth-password (string) \u2014 If the Sqedule server is protected by HTTP basic authentication, then specify the password here. debug (boolean, default: false) Subcommand-specific options To learn about subcommand-specific options, please run the subcommand with --help . The supported CLI parameters are all the configuration options that that subcommand supports.","title":"CLI configuration"},{"location":"user_guide/references/cli-config/#cli-configuration-reference","text":"See also Concept: CLI","title":"CLI configuration reference"},{"location":"user_guide/references/cli-config/#ways-to-pass-configuration","text":"There are 3 ways to pass configuration to the CLI. Configuration file . It's located in ~/.sqedule-cli.yaml by default. You can customize the location by running the CLI with --config /path-to-actual-file.yml . Environment variables . In some CI/CD pipelines, it's more convenient to set environment variables than to set CLI parameters. The tutorials demonstrate passing configuration via environment variables in the CI/CD pipeline. CLI parameters .","title":"Ways to pass configuration"},{"location":"user_guide/references/cli-config/#naming-format","text":"Configuration options have a canonical name , for example server-base-url . When using the configuration file, specify configuration options using their canonical names. Example: server-base-url: https://your-sqedule-server.com When using environment variables, specify configuration options with the SQEDULE_ prefix, in uppercase, with dashes ( - ) replaced by underscores ( _ ). Example: SQEDULE_SERVER_BASE_URL: https://your-sqedule-server.com When using CLI parameters, specify two dashes ( -- ) followed by the canonical name. Example: --server-base-url=something Caveat When setting a boolean option using a CLI parameter, be sure to specify the value after a = , like this: --something=true_or_false . Specifying the value after a space, like --something true_or_false doesn't work. Note The rest of the User Guide only specifies configuration names in their canonical format.","title":"Naming format"},{"location":"user_guide/references/cli-config/#precedence","text":"Configuration is loaded in the given order (least to most important): Config file Environment variables CLI parameters CLI parameters override environment variables. Environment variables override the configuration file.","title":"Precedence"},{"location":"user_guide/references/cli-config/#global-options","text":"These options apply to all subcommands. server-base-url (string, required) \u2014 The base URL of the Sqedule server to use. Example: https://your-sqedule-server.com basic-auth-user (string) \u2014 If the Sqedule server is protected by HTTP basic authentication, then specify the username here. basic-auth-password (string) \u2014 If the Sqedule server is protected by HTTP basic authentication, then specify the password here. debug (boolean, default: false)","title":"Global options"},{"location":"user_guide/references/cli-config/#subcommand-specific-options","text":"To learn about subcommand-specific options, please run the subcommand with --help . The supported CLI parameters are all the configuration options that that subcommand supports.","title":"Subcommand-specific options"},{"location":"user_guide/tasks/initial-cli-setup/","text":"Initial CLI setup Before we can use the Sqedule CLI, we must configure it to tell it which Sqedule server to use. Edit the Sqedule configuration file: Unix: ~/.sqedule-cli.yaml Windows: C:\\Users\\<Username>\\.sqedule-cli.yaml In this file: server-base-url : https://your-sqedule-server.com If the Sqedule server is behind a reverse proxy with HTTP Basic Authentication, then also specify the Basic Authentication credentials: basic-auth-user : <username here> basic-auth-password : <password here> On Unix, be sure to restrict the file's permissions so that the credentials can't be read by other users: chmod 600 ~/.sqedule-cli.yaml","title":"Initial CLI setup"},{"location":"user_guide/tasks/initial-cli-setup/#initial-cli-setup","text":"Before we can use the Sqedule CLI, we must configure it to tell it which Sqedule server to use. Edit the Sqedule configuration file: Unix: ~/.sqedule-cli.yaml Windows: C:\\Users\\<Username>\\.sqedule-cli.yaml In this file: server-base-url : https://your-sqedule-server.com If the Sqedule server is behind a reverse proxy with HTTP Basic Authentication, then also specify the Basic Authentication credentials: basic-auth-user : <username here> basic-auth-password : <password here> On Unix, be sure to restrict the file's permissions so that the credentials can't be read by other users: chmod 600 ~/.sqedule-cli.yaml","title":"Initial CLI setup"},{"location":"user_guide/tasks/install-cli/","text":"Installing the CLI See also Concept: About the CLI Download a Sqedule CLI binary tarball ( sqedule-cli-XXX-linux-x86_64.tar.gz ). Extract this tarball somewhere. For example: cd /usr/local tar xzf sqedule-cli-XXX.tar.gz The Sqedule CLI is now available as /usr/local/sqedule-cli-XXX/sqedule . We recommend adding the directory to PATH. Try it out: export PATH = /usr/local/sqedule-cli-XXX: $PATH sqedule version Next up You must setup the CLI's initial configuration before the CLI can be used.","title":"Installing the CLI"},{"location":"user_guide/tasks/install-cli/#installing-the-cli","text":"See also Concept: About the CLI Download a Sqedule CLI binary tarball ( sqedule-cli-XXX-linux-x86_64.tar.gz ). Extract this tarball somewhere. For example: cd /usr/local tar xzf sqedule-cli-XXX.tar.gz The Sqedule CLI is now available as /usr/local/sqedule-cli-XXX/sqedule . We recommend adding the directory to PATH. Try it out: export PATH = /usr/local/sqedule-cli-XXX: $PATH sqedule version","title":"Installing the CLI"},{"location":"user_guide/tasks/install-cli/#next-up","text":"You must setup the CLI's initial configuration before the CLI can be used.","title":"Next up"},{"location":"user_guide/tutorials/approval/","text":"Tutorial 2: release approval In the tutorial 1 we integrated a CD pipeline with Sqedule so that all releases are logged in Sqedule. In this tutorial we'll not only use Sqedule to log releases, but also to approve releases. That is: the pipeline won't actually deploy until Sqedule has approved the release. To this end, we will also define approval rules . The CD pipeline will not only log releases in Sqedule, but will also wait for Sqedule's approval before deploying. Before you begin Please make sure you've done the following before proceeding with this tutorial: Setup a Sqedule server Install the CLI Follow tutorial 1 1 Define approval rules Important concepts to know when defining approval rules: Individual rules are grouped in a ruleset . A ruleset must be bound to an application. New releases for that application will be evaluated against all bound rulesets. At present, Sqedule only supports one type of rule: the so-called \"schedule rule\", which defines a time-of-day window in which releases are allowed. More rule types will be supported in the future as Sqedule receives further development. In this tutorial we'll define a ruleset named \"only afternoon\", which only allows releases to occur from 12:00 to 18:00. 1 Create ruleset Let's create a ruleset using the Sqedule CLI. This requires two parameters: An ID meant for machines. It will also be used in URLs. Example: only_afternoon A human-readable display name. Example: \"Only afternoon\" Unix sqedule approval-ruleset create \\ --id only_afternoon \\ --display-name 'Only afternoon' Windows (cmd) sqedule approval-ruleset create ^ --id only_afternoon ^ --display-name \"Only afternoon\" Unlike tutorial 1, we don't specify --proposal-state final . That's because we aren't done editing this ruleset yet: we still need to add a rule to this ruleset. We'll finalize the proposal after we're done adding a rule. The CLI confirms that creating this ruleset was successful: { \"application_approval_ruleset_bindings\" : [], \"created_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"id\" : \"only_afternoon\" , \"updated_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"version\" : { \"proposal_state\" : \"draft\" , \"approval_rules\" : [], \"approved_at\" : null , \"created_at\" : \"2021-08-22T17:17:48.148982+02:00\" , \"description\" : \"\" , \"display_name\" : \"Only afternoon\" , \"enabled\" : true , \"globally_applicable\" : false , \"id\" : 5 , \"release_approval_ruleset_bindings\" : [], \"updated_at\" : \"2021-08-22T17:17:48.155585+02:00\" , \"version_number\" : null , \"version_state\" : \"proposal\" } } -------------------- \ud83c\udf89 Approval rulese t 'o nl y_a ftern oo n ' crea te d! \ud83d\udca1 I t is s t ill a proposal. To view i t , use `sqedule approval - rulese t proposal lis t ` \u26a0\ufe0f I t has n o rules ye t . To add rules , use `sqedule approval - rulese t proposal rule crea te -... ` According to version.version_state , this ruleset has one version, which is a proposal. Take note of the proposal ID! You can find that in version.id , which in the above example is 5. We'll need it for adding rules to this proposal. 2 Add rule Let's add a schedule rule to this ruleset proposal. This requires the following parameters: The ruleset's ID. Example: only_afternoon The proposal's ID. In the above example, it's 5. Schedule rule parameters. Unix sqedule approval-ruleset proposal rule create-schedule \\ --approval-ruleset-id only_afternoon \\ --proposal-id 5 \\ --begin-time '12:00' \\ --end-time '18:00' Windows (cmd) sqedule approval-ruleset proposal rule create-schedule ^ --approval-ruleset-id only_afternoon ^ --proposal-id 5 ^ --begin-time 12:00 ^ --end-time 18:00 The CLI confirms that the rule is successfully created: [ { \"begin_time\" : \"12:00\" , \"created_at\" : \"2021-08-22T17:25:36.952222+02:00\" , \"days_of_month\" : null , \"days_of_week\" : null , \"enabled\" : true , \"end_time\" : \"18:00\" , \"id\" : 5 , \"months_of_year\" : null , \"type\" : \"schedule\" } ] -------------------- \ud83c\udf89 Rule crea te d! 3 Finalize ruleset proposal We're done editing this ruleset proposal so let's finalize it. This requires the following parameters: The ruleset's ID. Example: only_afternoon The proposal's ID. In this example, it's 5. Unix sqedule approval-ruleset proposal update \\ --approval-ruleset-id only_afternoon \\ --id 5 \\ --proposal-state final Windows (cmd) sqedule approval-ruleset proposal update ^ --approval-ruleset-id only_afternoon ^ --id 5 ^ --proposal-state final The CLI confirms that finalization is successful ( version.state is approved ): { \"application_approval_ruleset_bindings\" : [], \"created_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"id\" : \"only_afternoon\" , \"updated_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"version\" : { \"proposal_state\" : \"approved\" , \"approval_rules\" : [ { \"begin_time\" : \"12:00\" , \"created_at\" : \"2021-08-22T17:25:36.952222+02:00\" , \"days_of_month\" : null , \"days_of_week\" : null , \"enabled\" : true , \"end_time\" : \"18:00\" , \"id\" : 6 , \"months_of_year\" : null , \"type\" : \"schedule\" } ], \"approved_at\" : \"2021-08-22T17:29:24.235901+02:00\" , \"created_at\" : \"2021-08-22T17:17:48.148982+02:00\" , \"description\" : \"\" , \"display_name\" : \"Only afternoon\" , \"enabled\" : true , \"globally_applicable\" : false , \"id\" : 5 , \"release_approval_ruleset_bindings\" : [], \"updated_at\" : \"2021-08-22T17:29:24.252494+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" } } -------------------- \ud83c\udf89 Proposal upda te d! 4 Bind ruleset to application Now that the ruleset is finished, we must bind it to an application. Only after binding will new releases be evaluated against this ruleset. To bind, we create an application approval ruleset binding . This requires the following parameters: The ID of the application to bind against. Example: shopping_cart_service The ID of the ruleset to bind against. Example: only_afternoon Unix sqedule application-approval-ruleset-binding create \\ --application-id shopping_cart_service \\ --approval-ruleset-id only_afternoon \\ --proposal-state final Windows (cmd) sqedule application-approval-ruleset-binding create ^ --application-id shopping_cart_service ^ --approval-ruleset-id only_afternoon ^ --proposal-state final The CLI confirms that the binding is created and that its version is finalized: { \"application\" : { \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"id\" : \"shopping_cart_service\" , \"latest_approved_version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , \"enabled\" : true , \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" }, \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" }, \"approval_ruleset\" : { \"created_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"id\" : \"only_afternoon\" , \"latest_approved_version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T17:29:24.235901+02:00\" , \"created_at\" : \"2021-08-22T17:17:48.148982+02:00\" , \"description\" : \"\" , \"display_name\" : \"Only afternoon\" , \"enabled\" : true , \"globally_applicable\" : false , \"id\" : 5 , \"updated_at\" : \"2021-08-22T17:29:24.252494+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" }, \"updated_at\" : \"2021-08-22T17:17:48.14245+02:00\" }, \"created_at\" : \"2021-08-22T20:13:44.264493+02:00\" , \"updated_at\" : \"2021-08-22T20:13:44.264493+02:00\" , \"version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T20:13:44.264346+02:00\" , \"created_at\" : \"2021-08-22T20:13:44.267858+02:00\" , \"id\" : 7 , \"mode\" : \"enforcing\" , \"updated_at\" : \"2021-08-22T20:13:44.273691+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" } } -------------------- \ud83c\udf89 Applica t io n approval rulese t bi n di n g bi n di n g crea te d! \ud83d\udca1 I t has bee n au t o - approved by t he sys te m. To view i t , use `sqedule applica t io n - approval - rulese t - bi n di n g describe` 2 Modify pipeline Open .github/workflows/cd.yml . Modify the \"Register release\" step and add the environment variable SQEDULE_WAIT: true . This parameter tells sqedule release create to not only register a release, but also to wait until it's either approved or rejected. name : CD on : push : {} jobs : deploy : runs-on : ubuntu-20.04 steps : - uses : actions/checkout@v2 - name : Download Sqedule CLI run : curl -fsSLo sqedule-cli.tar.gz https://github.com/fullstaq-labs/sqedule/releases/download/v0.1.0/sqedule-cli-0.1.0-x86_64-linux.tar.gz - name : Extract Sqedule CLI run : tar -xzf sqedule-cli.tar.gz --strip-components=1 - name : Register release run : ./sqedule release create env : SQEDULE_SERVER_BASE_URL : https://your-sqedule-server.com # <--- change this! SQEDULE_APPLICATION_ID : shopping_cart_service SQEDULE_METADATA : | { \"commit_sha\": \"${{ github.sha }}\", \"run_number\": ${{ github.run_number }} } ### Begin modification SQEDULE_WAIT : true ### End modification - run : echo I have deployed Commit and push the changes: git commit -a -m \"Approve releases via Sqedule\" git push Then wait until the CD pipeline finishes. You should see that it waits until the Sqedule server approves or rejects the release: Checking release state... Current state: pending Checking release state... Current state: pending ... Checking release state... Current state: approved About polling in the pipeline At present, deploying only after a release is approved or rejected by Sqedule, is implemented through polling in the pipeline. As you can imagine, this is suboptimal: it is inefficient and also ties up a pipeline executor or concurrency slot. At present, polling is the only release gate strategy that Sqedule supports because it's easy to implement and works with every pipeline. We plan to support additional release gate strategies in the future that don't involve polling (e.g. the ability to trigger Github/Gitlab pipelines from Sqedule after a release is approved/rejected). Conclusion Congratulations, you've implemented a pipeline that deploys only when the Sqedule server approves the release! We recommend that you read the Concepts section in order to familiarize yourself with Sqedule.","title":"2 Release approval"},{"location":"user_guide/tutorials/approval/#tutorial-2-release-approval","text":"In the tutorial 1 we integrated a CD pipeline with Sqedule so that all releases are logged in Sqedule. In this tutorial we'll not only use Sqedule to log releases, but also to approve releases. That is: the pipeline won't actually deploy until Sqedule has approved the release. To this end, we will also define approval rules . The CD pipeline will not only log releases in Sqedule, but will also wait for Sqedule's approval before deploying.","title":"Tutorial 2: release approval"},{"location":"user_guide/tutorials/approval/#before-you-begin","text":"Please make sure you've done the following before proceeding with this tutorial: Setup a Sqedule server Install the CLI Follow tutorial 1","title":"Before you begin"},{"location":"user_guide/tutorials/approval/#1-define-approval-rules","text":"Important concepts to know when defining approval rules: Individual rules are grouped in a ruleset . A ruleset must be bound to an application. New releases for that application will be evaluated against all bound rulesets. At present, Sqedule only supports one type of rule: the so-called \"schedule rule\", which defines a time-of-day window in which releases are allowed. More rule types will be supported in the future as Sqedule receives further development. In this tutorial we'll define a ruleset named \"only afternoon\", which only allows releases to occur from 12:00 to 18:00.","title":"1 Define approval rules"},{"location":"user_guide/tutorials/approval/#1-create-ruleset","text":"Let's create a ruleset using the Sqedule CLI. This requires two parameters: An ID meant for machines. It will also be used in URLs. Example: only_afternoon A human-readable display name. Example: \"Only afternoon\" Unix sqedule approval-ruleset create \\ --id only_afternoon \\ --display-name 'Only afternoon' Windows (cmd) sqedule approval-ruleset create ^ --id only_afternoon ^ --display-name \"Only afternoon\" Unlike tutorial 1, we don't specify --proposal-state final . That's because we aren't done editing this ruleset yet: we still need to add a rule to this ruleset. We'll finalize the proposal after we're done adding a rule. The CLI confirms that creating this ruleset was successful: { \"application_approval_ruleset_bindings\" : [], \"created_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"id\" : \"only_afternoon\" , \"updated_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"version\" : { \"proposal_state\" : \"draft\" , \"approval_rules\" : [], \"approved_at\" : null , \"created_at\" : \"2021-08-22T17:17:48.148982+02:00\" , \"description\" : \"\" , \"display_name\" : \"Only afternoon\" , \"enabled\" : true , \"globally_applicable\" : false , \"id\" : 5 , \"release_approval_ruleset_bindings\" : [], \"updated_at\" : \"2021-08-22T17:17:48.155585+02:00\" , \"version_number\" : null , \"version_state\" : \"proposal\" } } -------------------- \ud83c\udf89 Approval rulese t 'o nl y_a ftern oo n ' crea te d! \ud83d\udca1 I t is s t ill a proposal. To view i t , use `sqedule approval - rulese t proposal lis t ` \u26a0\ufe0f I t has n o rules ye t . To add rules , use `sqedule approval - rulese t proposal rule crea te -... ` According to version.version_state , this ruleset has one version, which is a proposal. Take note of the proposal ID! You can find that in version.id , which in the above example is 5. We'll need it for adding rules to this proposal.","title":"1 Create ruleset"},{"location":"user_guide/tutorials/approval/#2-add-rule","text":"Let's add a schedule rule to this ruleset proposal. This requires the following parameters: The ruleset's ID. Example: only_afternoon The proposal's ID. In the above example, it's 5. Schedule rule parameters. Unix sqedule approval-ruleset proposal rule create-schedule \\ --approval-ruleset-id only_afternoon \\ --proposal-id 5 \\ --begin-time '12:00' \\ --end-time '18:00' Windows (cmd) sqedule approval-ruleset proposal rule create-schedule ^ --approval-ruleset-id only_afternoon ^ --proposal-id 5 ^ --begin-time 12:00 ^ --end-time 18:00 The CLI confirms that the rule is successfully created: [ { \"begin_time\" : \"12:00\" , \"created_at\" : \"2021-08-22T17:25:36.952222+02:00\" , \"days_of_month\" : null , \"days_of_week\" : null , \"enabled\" : true , \"end_time\" : \"18:00\" , \"id\" : 5 , \"months_of_year\" : null , \"type\" : \"schedule\" } ] -------------------- \ud83c\udf89 Rule crea te d!","title":"2 Add rule"},{"location":"user_guide/tutorials/approval/#3-finalize-ruleset-proposal","text":"We're done editing this ruleset proposal so let's finalize it. This requires the following parameters: The ruleset's ID. Example: only_afternoon The proposal's ID. In this example, it's 5. Unix sqedule approval-ruleset proposal update \\ --approval-ruleset-id only_afternoon \\ --id 5 \\ --proposal-state final Windows (cmd) sqedule approval-ruleset proposal update ^ --approval-ruleset-id only_afternoon ^ --id 5 ^ --proposal-state final The CLI confirms that finalization is successful ( version.state is approved ): { \"application_approval_ruleset_bindings\" : [], \"created_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"id\" : \"only_afternoon\" , \"updated_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"version\" : { \"proposal_state\" : \"approved\" , \"approval_rules\" : [ { \"begin_time\" : \"12:00\" , \"created_at\" : \"2021-08-22T17:25:36.952222+02:00\" , \"days_of_month\" : null , \"days_of_week\" : null , \"enabled\" : true , \"end_time\" : \"18:00\" , \"id\" : 6 , \"months_of_year\" : null , \"type\" : \"schedule\" } ], \"approved_at\" : \"2021-08-22T17:29:24.235901+02:00\" , \"created_at\" : \"2021-08-22T17:17:48.148982+02:00\" , \"description\" : \"\" , \"display_name\" : \"Only afternoon\" , \"enabled\" : true , \"globally_applicable\" : false , \"id\" : 5 , \"release_approval_ruleset_bindings\" : [], \"updated_at\" : \"2021-08-22T17:29:24.252494+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" } } -------------------- \ud83c\udf89 Proposal upda te d!","title":"3 Finalize ruleset proposal"},{"location":"user_guide/tutorials/approval/#4-bind-ruleset-to-application","text":"Now that the ruleset is finished, we must bind it to an application. Only after binding will new releases be evaluated against this ruleset. To bind, we create an application approval ruleset binding . This requires the following parameters: The ID of the application to bind against. Example: shopping_cart_service The ID of the ruleset to bind against. Example: only_afternoon Unix sqedule application-approval-ruleset-binding create \\ --application-id shopping_cart_service \\ --approval-ruleset-id only_afternoon \\ --proposal-state final Windows (cmd) sqedule application-approval-ruleset-binding create ^ --application-id shopping_cart_service ^ --approval-ruleset-id only_afternoon ^ --proposal-state final The CLI confirms that the binding is created and that its version is finalized: { \"application\" : { \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"id\" : \"shopping_cart_service\" , \"latest_approved_version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , \"enabled\" : true , \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" }, \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" }, \"approval_ruleset\" : { \"created_at\" : \"2021-08-22T17:17:48.14245+02:00\" , \"id\" : \"only_afternoon\" , \"latest_approved_version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T17:29:24.235901+02:00\" , \"created_at\" : \"2021-08-22T17:17:48.148982+02:00\" , \"description\" : \"\" , \"display_name\" : \"Only afternoon\" , \"enabled\" : true , \"globally_applicable\" : false , \"id\" : 5 , \"updated_at\" : \"2021-08-22T17:29:24.252494+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" }, \"updated_at\" : \"2021-08-22T17:17:48.14245+02:00\" }, \"created_at\" : \"2021-08-22T20:13:44.264493+02:00\" , \"updated_at\" : \"2021-08-22T20:13:44.264493+02:00\" , \"version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T20:13:44.264346+02:00\" , \"created_at\" : \"2021-08-22T20:13:44.267858+02:00\" , \"id\" : 7 , \"mode\" : \"enforcing\" , \"updated_at\" : \"2021-08-22T20:13:44.273691+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" } } -------------------- \ud83c\udf89 Applica t io n approval rulese t bi n di n g bi n di n g crea te d! \ud83d\udca1 I t has bee n au t o - approved by t he sys te m. To view i t , use `sqedule applica t io n - approval - rulese t - bi n di n g describe`","title":"4 Bind ruleset to application"},{"location":"user_guide/tutorials/approval/#2-modify-pipeline","text":"Open .github/workflows/cd.yml . Modify the \"Register release\" step and add the environment variable SQEDULE_WAIT: true . This parameter tells sqedule release create to not only register a release, but also to wait until it's either approved or rejected. name : CD on : push : {} jobs : deploy : runs-on : ubuntu-20.04 steps : - uses : actions/checkout@v2 - name : Download Sqedule CLI run : curl -fsSLo sqedule-cli.tar.gz https://github.com/fullstaq-labs/sqedule/releases/download/v0.1.0/sqedule-cli-0.1.0-x86_64-linux.tar.gz - name : Extract Sqedule CLI run : tar -xzf sqedule-cli.tar.gz --strip-components=1 - name : Register release run : ./sqedule release create env : SQEDULE_SERVER_BASE_URL : https://your-sqedule-server.com # <--- change this! SQEDULE_APPLICATION_ID : shopping_cart_service SQEDULE_METADATA : | { \"commit_sha\": \"${{ github.sha }}\", \"run_number\": ${{ github.run_number }} } ### Begin modification SQEDULE_WAIT : true ### End modification - run : echo I have deployed Commit and push the changes: git commit -a -m \"Approve releases via Sqedule\" git push Then wait until the CD pipeline finishes. You should see that it waits until the Sqedule server approves or rejects the release: Checking release state... Current state: pending Checking release state... Current state: pending ... Checking release state... Current state: approved","title":"2 Modify pipeline"},{"location":"user_guide/tutorials/approval/#about-polling-in-the-pipeline","text":"At present, deploying only after a release is approved or rejected by Sqedule, is implemented through polling in the pipeline. As you can imagine, this is suboptimal: it is inefficient and also ties up a pipeline executor or concurrency slot. At present, polling is the only release gate strategy that Sqedule supports because it's easy to implement and works with every pipeline. We plan to support additional release gate strategies in the future that don't involve polling (e.g. the ability to trigger Github/Gitlab pipelines from Sqedule after a release is approved/rejected).","title":"About polling in the pipeline"},{"location":"user_guide/tutorials/approval/#conclusion","text":"Congratulations, you've implemented a pipeline that deploys only when the Sqedule server approves the release! We recommend that you read the Concepts section in order to familiarize yourself with Sqedule.","title":"Conclusion"},{"location":"user_guide/tutorials/release-logging/","text":"Tutorial 1: release audit logging In this tutorial, we will: Create a Github repository with a CD pipeline. Configure the CLI . Register an application in Sqedule using the CLI. We will touch upon the Versioning concept. Integrate a CD pipeline with Sqedule, so that the pipeline registers a release in Sqedule. The pipeline will make use of the CLI. View a list of releases for the registered applications. We will integrate a CD pipeline with Sqedule. The pipeline will register releases in the Sqedule server. Before you begin Please make sure you've done the following before proceeding with this tutorial: Setup a Sqedule server Install the CLI 1 Create Github repo with pipeline Create a new Git repo: mkdir sqedule-tutorial-1 cd sqedule-tutorial-1 git init Add a new Github workflow representing our CD pipeline. Since this is just a tutorial, this pipeline doesn't actually deploy anything and merely prints \"I have deployed\". In .github/workflows/cd.yml : name : CD on : push : {} jobs : deploy : runs-on : ubuntu-20.04 steps : - uses : actions/checkout@v2 - run : echo I have deployed Commit the file: git add .github/workflows/ci.yml git commit -a -m \"Initial commit\" Then create a Github repo and push this Git repo to Github. 2 Configure CLI Before we can use the Sqedule CLI, we must configure it to tell it which Sqedule server to use. Edit the Sqedule configuration file: Unix: ~/.sqedule-cli.yaml Windows: C:\\Users\\<Username>\\.sqedule-cli.yaml In this file: server-base-url : https://your-sqedule-server.com If the Sqedule server is behind a reverse proxy with HTTP Basic Authentication, then also specify the Basic Authentication credentials: basic-auth-user : <username here> basic-auth-password : <password here> On Unix, be sure to restrict the file's permissions so that the credentials can't be read by other users: chmod 600 ~/.sqedule-cli.yaml 3 Register an application Use the CLI to register an application. This requires two parameters: An ID meant for machines. It will also be used in URLs. Example: shopping_cart_service A human-readable display name. Example: \"Shopping Cart Service\" Unix sqedule application create \\ --id shopping_cart_service \\ --display-name 'Shopping Cart Service' \\ --proposal-state final Windows (cmd) sqedule application create ^ --id shopping_cart_service ^ --display-name \"Shopping Cart Service\" ^ --proposal-state final Proposal state? Many resources in Sqedule are versioned. There are two kinds of versions: proposals (unapproved versions), and approved versions. Proposals can be modified at will and have no effect. Once you are satisfied with the proposal, you finalize the proposal, after which it may become an approved version (approval is done either by change managers or automatically by the system). sqedule xxx create commands don't create finalized versions by default. Instead, they create draft (unfinalized) proposals. The --proposal-state final flag indicates that we want to finalize the proposal and submit it for approval. Learn more about the concept: Versioning, proposals & reviews . The CLI tells you that the operation is successful, and outputs the properties of the registered application: { \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"id\" : \"shopping_cart_service\" , \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , \"enabled\" : true , \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" } } -------------------- \ud83c\udf89 Applica t io n crea te d! \ud83d\udca1 I t has bee n au t o - approved by t he sys te m. To view i t , use `sqedule applica t io n describe` Viewing the registered application With the CLI Run: sqedule application describe --id shopping_cart_service The CLI outputs the properties of the application: { \"approval_ruleset_bindings\" : [], \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"id\" : \"shopping_cart_service\" , \"latest_approved_version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , \"enabled\" : true , \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" }, \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" } With the web interface Visit your Sqedule server's base URL. That will open up the web interface . Click \"Applications\" and you should see your application. 4 Integrate with CD pipeline Modify .github/workflows/cd.yml to: Download and extract the Sqedule CLI. Use the Sqedule CLI to register a release before deploying. name : CD on : push : {} jobs : deploy : runs-on : ubuntu-20.04 steps : - uses : actions/checkout@v2 ### Begin modification - name : Download Sqedule CLI run : curl -fsSLo sqedule-cli.tar.gz https://github.com/fullstaq-labs/sqedule/releases/download/v0.1.0/sqedule-cli-0.1.0-x86_64-linux.tar.gz - name : Extract Sqedule CLI run : tar -xzf sqedule-cli.tar.gz --strip-components=1 - name : Register release run : ./sqedule release create env : SQEDULE_SERVER_BASE_URL : https://your-sqedule-server.com # <--- change this! SQEDULE_APPLICATION_ID : shopping_cart_service SQEDULE_METADATA : | { \"commit_sha\": \"${{ github.sha }}\", \"run_number\": ${{ github.run_number }} } ### End modification - run : echo I have deployed The most important addition is the sqedule release create invocation \u2014 this is the CLI command that registers a release. This command accepts the following parameters (which we pass via environment variables): The Sqedule server URL. The ID of the application for which we want to register a release. Arbitrary JSON metadata to include in the release. In this case, we include the Git commit SHA and the Github Actions run number. Commit and push the changes: git commit -a -m \"Log releases in Sqedule\" git push Then wait until the CD pipeline finishes. 5 View release Visit your Sqedule server's base URL. That will open up the web interface . Click \"Releases\" and you should see the release that just occurred. Conclusion Congratulations, you've integrated a CD pipeline with Sqedule! Every time the pipeline deploys, it registers a new release in Sqedule. In the next tutorial , we'll not only use Sqedule to log releases, but also to approve releases.","title":"1 Release audit logging"},{"location":"user_guide/tutorials/release-logging/#tutorial-1-release-audit-logging","text":"In this tutorial, we will: Create a Github repository with a CD pipeline. Configure the CLI . Register an application in Sqedule using the CLI. We will touch upon the Versioning concept. Integrate a CD pipeline with Sqedule, so that the pipeline registers a release in Sqedule. The pipeline will make use of the CLI. View a list of releases for the registered applications. We will integrate a CD pipeline with Sqedule. The pipeline will register releases in the Sqedule server.","title":"Tutorial 1: release audit logging"},{"location":"user_guide/tutorials/release-logging/#before-you-begin","text":"Please make sure you've done the following before proceeding with this tutorial: Setup a Sqedule server Install the CLI","title":"Before you begin"},{"location":"user_guide/tutorials/release-logging/#1-create-github-repo-with-pipeline","text":"Create a new Git repo: mkdir sqedule-tutorial-1 cd sqedule-tutorial-1 git init Add a new Github workflow representing our CD pipeline. Since this is just a tutorial, this pipeline doesn't actually deploy anything and merely prints \"I have deployed\". In .github/workflows/cd.yml : name : CD on : push : {} jobs : deploy : runs-on : ubuntu-20.04 steps : - uses : actions/checkout@v2 - run : echo I have deployed Commit the file: git add .github/workflows/ci.yml git commit -a -m \"Initial commit\" Then create a Github repo and push this Git repo to Github.","title":"1 Create Github repo with pipeline"},{"location":"user_guide/tutorials/release-logging/#2-configure-cli","text":"Before we can use the Sqedule CLI, we must configure it to tell it which Sqedule server to use. Edit the Sqedule configuration file: Unix: ~/.sqedule-cli.yaml Windows: C:\\Users\\<Username>\\.sqedule-cli.yaml In this file: server-base-url : https://your-sqedule-server.com If the Sqedule server is behind a reverse proxy with HTTP Basic Authentication, then also specify the Basic Authentication credentials: basic-auth-user : <username here> basic-auth-password : <password here> On Unix, be sure to restrict the file's permissions so that the credentials can't be read by other users: chmod 600 ~/.sqedule-cli.yaml","title":"2 Configure CLI"},{"location":"user_guide/tutorials/release-logging/#3-register-an-application","text":"Use the CLI to register an application. This requires two parameters: An ID meant for machines. It will also be used in URLs. Example: shopping_cart_service A human-readable display name. Example: \"Shopping Cart Service\" Unix sqedule application create \\ --id shopping_cart_service \\ --display-name 'Shopping Cart Service' \\ --proposal-state final Windows (cmd) sqedule application create ^ --id shopping_cart_service ^ --display-name \"Shopping Cart Service\" ^ --proposal-state final Proposal state? Many resources in Sqedule are versioned. There are two kinds of versions: proposals (unapproved versions), and approved versions. Proposals can be modified at will and have no effect. Once you are satisfied with the proposal, you finalize the proposal, after which it may become an approved version (approval is done either by change managers or automatically by the system). sqedule xxx create commands don't create finalized versions by default. Instead, they create draft (unfinalized) proposals. The --proposal-state final flag indicates that we want to finalize the proposal and submit it for approval. Learn more about the concept: Versioning, proposals & reviews . The CLI tells you that the operation is successful, and outputs the properties of the registered application: { \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"id\" : \"shopping_cart_service\" , \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , \"enabled\" : true , \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" } } -------------------- \ud83c\udf89 Applica t io n crea te d! \ud83d\udca1 I t has bee n au t o - approved by t he sys te m. To view i t , use `sqedule applica t io n describe`","title":"3 Register an application"},{"location":"user_guide/tutorials/release-logging/#viewing-the-registered-application","text":"","title":"Viewing the registered application"},{"location":"user_guide/tutorials/release-logging/#with-the-cli","text":"Run: sqedule application describe --id shopping_cart_service The CLI outputs the properties of the application: { \"approval_ruleset_bindings\" : [], \"created_at\" : \"2021-08-22T14:44:14.115866+02:00\" , \"id\" : \"shopping_cart_service\" , \"latest_approved_version\" : { \"proposal_state\" : \"approved\" , \"approved_at\" : \"2021-08-22T14:44:14.115686+02:00\" , \"created_at\" : \"2021-08-22T14:44:14.11635+02:00\" , \"display_name\" : \"Shopping Cart Service\" , \"enabled\" : true , \"id\" : 738 , \"updated_at\" : \"2021-08-22T14:44:14.11722+02:00\" , \"version_number\" : 1 , \"version_state\" : \"approved\" }, \"updated_at\" : \"2021-08-22T14:44:14.115866+02:00\" }","title":"With the CLI"},{"location":"user_guide/tutorials/release-logging/#with-the-web-interface","text":"Visit your Sqedule server's base URL. That will open up the web interface . Click \"Applications\" and you should see your application.","title":"With the web interface"},{"location":"user_guide/tutorials/release-logging/#4-integrate-with-cd-pipeline","text":"Modify .github/workflows/cd.yml to: Download and extract the Sqedule CLI. Use the Sqedule CLI to register a release before deploying. name : CD on : push : {} jobs : deploy : runs-on : ubuntu-20.04 steps : - uses : actions/checkout@v2 ### Begin modification - name : Download Sqedule CLI run : curl -fsSLo sqedule-cli.tar.gz https://github.com/fullstaq-labs/sqedule/releases/download/v0.1.0/sqedule-cli-0.1.0-x86_64-linux.tar.gz - name : Extract Sqedule CLI run : tar -xzf sqedule-cli.tar.gz --strip-components=1 - name : Register release run : ./sqedule release create env : SQEDULE_SERVER_BASE_URL : https://your-sqedule-server.com # <--- change this! SQEDULE_APPLICATION_ID : shopping_cart_service SQEDULE_METADATA : | { \"commit_sha\": \"${{ github.sha }}\", \"run_number\": ${{ github.run_number }} } ### End modification - run : echo I have deployed The most important addition is the sqedule release create invocation \u2014 this is the CLI command that registers a release. This command accepts the following parameters (which we pass via environment variables): The Sqedule server URL. The ID of the application for which we want to register a release. Arbitrary JSON metadata to include in the release. In this case, we include the Git commit SHA and the Github Actions run number. Commit and push the changes: git commit -a -m \"Log releases in Sqedule\" git push Then wait until the CD pipeline finishes.","title":"4 Integrate with CD pipeline"},{"location":"user_guide/tutorials/release-logging/#5-view-release","text":"Visit your Sqedule server's base URL. That will open up the web interface . Click \"Releases\" and you should see the release that just occurred.","title":"5 View release"},{"location":"user_guide/tutorials/release-logging/#conclusion","text":"Congratulations, you've integrated a CD pipeline with Sqedule! Every time the pipeline deploys, it registers a new release in Sqedule. In the next tutorial , we'll not only use Sqedule to log releases, but also to approve releases.","title":"Conclusion"}]}